<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Walking Solitaire (Light) ‚Äî Spider / Scorpion / Golf</title>
  <style>
    :root{
      --bg:#0f3a33;
      --panel:#f7faf9;
      --ink:#0b1512;
      --muted:#5b6b66;
      --btn:#1f6b5e;
      --btn2:#155347;
      --line:rgba(255,255,255,.18);
      --danger:#b43a3a;
      --good:#1f8a6a;
      --cardW: clamp(44px, 11.5vw, 58px);
      --cardH: calc(var(--cardW) * 1.35);
      --gap: 8px;
      --radius: 16px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color:#eaf3f0;
    }
    header{
      position: sticky; top:0; z-index: 20;
      background: rgba(15,58,51,.92);
      backdrop-filter: blur(6px);
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .brand{ font-weight:800; letter-spacing:.2px; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border:1px solid var(--line);
      border-radius:999px;
      background: rgba(255,255,255,.06);
      font-weight:700;
    }
    .small{ font-size:12px; opacity:.9; font-weight:600; }
    .wrap{ max-width: 980px; margin: 0 auto; padding: 12px; }
    .card{
      background: var(--panel);
      color: var(--ink);
      border-radius: var(--radius);
      padding: 14px;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 860px){
      .grid{ grid-template-columns: 360px 1fr; align-items:start; }
    }
    button, .btn{
      appearance:none; border:0;
      background: var(--btn);
      color:white;
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 800;
      letter-spacing:.2px;
      cursor:pointer;
    }
    button.secondary{ background: rgba(255,255,255,.10); border: 1px solid var(--line); }
    button.ghost{ background: transparent; border:1px solid var(--line); }
    button.danger{ background: var(--danger); }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .tabs{ display:flex; gap:8px; flex-wrap:wrap; }
    .tab{ padding:10px 12px; border-radius:999px; border:1px solid var(--line); background: rgba(255,255,255,.08); font-weight:800; }
    .tab.active{ background: rgba(255,255,255,.16); }
    .muted{ color: var(--muted); }
    .hintBox{
      border:1px solid rgba(0,0,0,.10);
      border-radius: 14px;
      padding: 12px;
      background: #ffffff;
    }
    .hintTitle{ font-weight:900; }
    .hintText{ margin-top:6px; line-height:1.35; }
    .controls{ display:flex; gap:8px; flex-wrap:wrap; }
    .divider{ height:1px; background: rgba(0,0,0,.10); margin: 10px 0; }

    /* TABLEAUs */
    .tableauWrap{
      border-radius: var(--radius);
      border: 1px dashed rgba(255,255,255,.30);
      padding: 10px;
      overflow: hidden;
    }
    .tableau{
      display:flex;
      gap: var(--gap);
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 8px;
      scroll-snap-type:x proximity;
    }
    .col{
      position: relative;
      min-width: calc(var(--cardW) + 8px);
      scroll-snap-align:start;
      padding: 4px 4px 10px 4px;
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 14px;
      background: rgba(0,0,0,.06);
    }
    .colHeader{
      display:flex; justify-content:space-between; align-items:center;
      font-size: 11px; font-weight:800; opacity:.9;
      margin-bottom: 6px;
    }
    .stack{
      position: relative;
      min-height: calc(var(--cardH) + 8px);
    }
    .cardDiv{
      position: relative;
      width: var(--cardW);
      height: var(--cardH);
      border-radius: 12px;
      background: #fff;
      border: 1px solid rgba(0,0,0,.14);
      display:flex; align-items:center; justify-content:center;
      font-weight: 900;
      user-select:none;
      touch-action: manipulation;
      margin: 0 auto;
    }
    /* overlap: next cards rise upward slightly so ranks stay visible */
    .cardDiv + .cardDiv{ margin-top: calc(var(--cardH) * -0.78); }
    .cardDiv.faceDown{
      background: linear-gradient(135deg, #2b6c60, #10443b);
      border-color: rgba(255,255,255,.18);
      color: rgba(255,255,255,.85);
    }
    .cardDiv.sel{
      outline: 3px solid rgba(255,196,64,.95);
      outline-offset: 2px;
    }
    .cardDiv.bad{
      outline: 3px solid rgba(210,68,68,.95);
      outline-offset: 2px;
    }
    .topRow{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .slot{
      display:flex; align-items:center; gap:8px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.18);
      border-radius: 14px;
      background: rgba(255,255,255,.06);
      font-weight: 900;
    }
    .slot small{ font-weight:800; opacity:.85; }
    .foundationRow{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .foundationCard{
      width: var(--cardW);
      height: var(--cardH);
      border-radius: 12px;
      background:#fff;
      border:1px solid rgba(0,0,0,.14);
      display:flex; align-items:center; justify-content:center;
      font-weight: 900;
      color:#0b1512;
    }
    .overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.60);
      display:none;
      z-index: 9999;
      padding: 14px;
    }
    .overlay.show{ display:flex; align-items:center; justify-content:center; }
    .modal{
      width:min(520px, 92vw);
      border-radius: 18px;
      background: #f7faf9;
      color:#0b1512;
      padding: 16px;
      border: 1px solid rgba(0,0,0,.12);
    }
    .modal h2{ margin:0 0 6px 0; font-size: 20px; }
    .modal p{ margin: 6px 0; line-height:1.35; }
    .modal .actions{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .kicker{ font-size: 12px; color:#41524d; font-weight:800; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    footer{
      padding: 16px 0 22px;
      opacity:.9;
    }
    a{ color:#d7fff3; }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <div class="brand">üï∑Ô∏è Walking Solitaire (Light)</div>
      <div class="pill">üî• Striikki <span id="streak">0</span></div>
      <div class="pill">‚úÖ P√§iv√§ tehty <span id="dayDone">ei</span></div>
      <div class="pill">ü™ô Token <span id="tokens">0</span></div>
      <div class="pill">üéØ Tavoite <span id="goalMin">5</span> min</div>
    </div>
  </header>

  <div class="wrap">
    <div class="grid">
      <!-- LEFT: Walking + Teacher + Break info -->
      <div class="card">
        <h2 style="margin:0 0 6px 0;">P√§iv√§n k√§velyvelvoite</h2>
        <div class="muted" style="font-weight:700; line-height:1.35;">
          Valitse tavoite (3/5/7 min). Kun t√§yt√§t, pelit aukeavat.
          K√§velytilassa kosketus voidaan lukita, jotta et ‚Äúvahingossa j√§√§‚Äù puhelimeen.
        </div>

        <div class="divider"></div>

        <div class="controls">
          <button class="secondary" id="g3">3 min</button>
          <button class="secondary" id="g5">5 min</button>
          <button class="secondary" id="g7">7 min</button>
        </div>

        <div style="height:10px;"></div>

        <div class="controls">
          <button id="startWalk">Aloita k√§vely-tila</button>
          <button class="ghost" id="toggleLock">Kosketus: lukossa</button>
        </div>

        <div style="height:10px;"></div>

        <div class="hintBox">
          <div class="hintTitle">‚è±Ô∏è K√§vely</div>
          <div class="hintText">
            Aikaa j√§ljell√§: <span class="mono" id="walkLeft">‚Äî</span><br/>
            T√§n√§√§n tehty: <b><span id="doneMin">0</span> min</b>
          </div>
        </div>

        <div class="divider"></div>

        <div class="hintBox" id="teacherBox">
          <div class="hintTitle">üéì Opettaja (ennen siirtoa)</div>
          <div class="hintText" id="teacherText">
            Valitse kortti ‚Üí opettaja ehdottaa parasta siirtoa (tai varoittaa virheest√§).
          </div>
        </div>

        <div class="divider"></div>

        <div class="hintBox">
          <div class="hintTitle">üß± Tauot + ‚Äúmainosmuuri‚Äù (testi)</div>
          <div class="hintText">
            Joka <b>25. siirto</b> tai <b>3 virheyrityst√§</b> k√§ynnist√§√§ <b>60s portin</b>.<br/>
            Portin j√§lkeen saat <b>+1 token</b>. Tokenilla voit ohittaa portin kerran.
          </div>
        </div>

        <div class="divider"></div>

        <button class="ghost" id="copyBtn">üìã Kopioi t√§m√§ (koko HTML)</button>
        <div class="kicker" style="margin-top:8px;">
          Kaikki data on localStorage:ssa (laitteessa). Ei l√§hetet√§ minnek√§√§n.
        </div>
      </div>

      <!-- RIGHT: Games -->
      <div>
        <div class="tabs" style="margin-bottom:10px;">
          <button class="tab active" id="tabSpider">üï∑Ô∏è Spider</button>
          <button class="tab" id="tabScorpion">ü¶Ç Scorpion</button>
          <button class="tab" id="tabGolf">‚õ≥ Golf</button>
        </div>

        <div class="card">
          <div class="topRow">
            <div class="slot">üìä Siirrot <span id="moves">0</span></div>
            <div class="slot">‚öë Valmis <span id="progress">0</span></div>
            <div class="slot">üì¶ Stock <span id="stockCount">0</span></div>
          </div>

          <div class="controls" style="margin-bottom:10px;">
            <button id="newGame">New game</button>
            <button class="secondary" id="restartDeal">Restart sama jako</button>
            <button class="secondary" id="undo">Undo</button>
            <button class="secondary" id="redo">Redo</button>
            <button class="ghost" id="deal">Deal</button>
          </div>

          <div class="hintBox" style="margin-bottom:10px;">
            <div class="hintTitle">Ohje</div>
            <div class="hintText" id="rulesText"></div>
          </div>

          <div class="foundationRow" id="foundationRow" style="margin-bottom:10px; display:none;">
            <div class="slot">üÇ† Foundation</div>
            <div class="foundationCard" id="foundationCard">‚Äî</div>
            <div class="slot">üì¶ Stock <span id="golfStock">0</span></div>
          </div>

          <div class="tableauWrap">
            <div class="tableau" id="tableau"></div>
          </div>

          <footer class="small" style="margin-top:10px;">
            Vinkki: Jos pelit eiv√§t aukea, tee ensin p√§iv√§n k√§vely (3/5/7 min).
          </footer>
        </div>
      </div>
    </div>
  </div>

  <!-- OVERLAYS -->
  <div class="overlay" id="gateOverlay">
    <div class="modal">
      <h2 id="gateTitle">Portti</h2>
      <p id="gateText"></p>
      <div class="kicker">Aikaa j√§ljell√§: <span class="mono" id="gateLeft">60</span>s</div>
      <div class="actions">
        <button id="gateOk" disabled>Jatka</button>
        <button class="secondary" id="gateSkip">Ohita tokenilla</button>
        <button class="ghost" id="gateWatch">‚ÄúKatso mainos‚Äù (testi)</button>
      </div>
      <p class="small muted" style="margin-top:10px;">
        Huom: T√§m√§ on testimalli selaimessa. Oikea ‚Äúrewarded ad‚Äù tulee yleens√§ mobiili-SDK:lla (APK), ei AdSense-sivumainoksilla.
      </p>
    </div>
  </div>

  <div class="overlay" id="walkOverlay">
    <div class="modal">
      <h2>üö∂ K√§vely-tila</h2>
      <p id="walkOverlayText"></p>
      <div class="kicker">Aikaa j√§ljell√§: <span class="mono" id="walkOverlayLeft">‚Äî</span></div>
      <div class="actions">
        <button class="secondary" id="walkStop">Lopeta</button>
      </div>
      <p class="small muted" style="margin-top:10px;">
        Vinkki: pid√§ puhelin k√§dess√§ ja k√§vele sis√§ll√§. T√§m√§ ei ole askelmittari, vaan velvoite-timer.
      </p>
    </div>
  </div>

<script>
(() => {
  // ---------- Utilities ----------
  const $ = (id) => document.getElementById(id);
  const todayISO = () => new Date().toISOString().slice(0,10);

  const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const rankVal = (r) => RANKS.indexOf(r) + 1;
  const valRank = (v) => RANKS[(v-1+13)%13];
  const SUITS = ["‚ô†","‚ô•","‚ô¶","‚ô£"]; // used visually, but Spider/Scorpion enforce suit in rules.

  function shuffle(arr, seed=null){
    // small deterministic-ish shuffle when seed provided
    let a = arr.slice();
    let x = seed ? (seed >>> 0) : (Date.now() >>> 0);
    const rnd = () => {
      // xorshift32
      x ^= x << 13; x >>>= 0;
      x ^= x >> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return (x >>> 0) / 4294967296;
    };
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(rnd()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function cloneState(s){
    return JSON.parse(JSON.stringify(s));
  }

  // ---------- Walking gate ----------
  const LS_KEY = "walking_solitaire_light_v1";
  const stateLS = (() => {
    try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); }
    catch { return {}; }
  })();

  function saveLS(){
    localStorage.setItem(LS_KEY, JSON.stringify(stateLS));
  }

  function ensureDay(){
    const d = todayISO();
    if(!stateLS.day || stateLS.day !== d){
      stateLS.day = d;
      stateLS.doneMin = 0;
      stateLS.goalMin = stateLS.goalMin ?? 5;
      // streak handling
      const prev = stateLS.prevDay;
      if(prev){
        // if yesterday done -> continue streak, else reset
        const y = new Date(); y.setDate(y.getDate()-1);
        const yISO = y.toISOString().slice(0,10);
        if(prev === yISO && stateLS.prevDone === true){
          stateLS.streak = (stateLS.streak||0) + 1;
        } else {
          stateLS.streak = 0;
        }
      } else {
        stateLS.streak = stateLS.streak || 0;
      }
      stateLS.prevDay = d;
      stateLS.prevDone = false;
      saveLS();
    }
  }

  ensureDay();

  // UI for walking
  let touchLocked = true;
  let walkTimer = null;
  let walkLeftSec = 0;

  function updateWalkUI(){
    $("goalMin").textContent = stateLS.goalMin || 5;
    $("doneMin").textContent = stateLS.doneMin || 0;
    $("streak").textContent = stateLS.streak || 0;
    const done = (stateLS.doneMin || 0) >= (stateLS.goalMin || 5);
    $("dayDone").textContent = done ? "kyll√§" : "ei";
    if(done) stateLS.prevDone = true;
    saveLS();
    $("walkLeft").textContent = walkLeftSec ? (walkLeftSec + " s") : "‚Äî";
    $("toggleLock").textContent = "Kosketus: " + (touchLocked ? "lukossa" : "auki");
  }
  updateWalkUI();

  $("g3").onclick = () => { stateLS.goalMin = 3; saveLS(); updateWalkUI(); };
  $("g5").onclick = () => { stateLS.goalMin = 5; saveLS(); updateWalkUI(); };
  $("g7").onclick = () => { stateLS.goalMin = 7; saveLS(); updateWalkUI(); };

  $("toggleLock").onclick = () => { touchLocked = !touchLocked; updateWalkUI(); };

  function showWalkOverlay(sec){
    walkLeftSec = sec;
    $("walkOverlayText").textContent = touchLocked
      ? "Kosketus on lukossa. Laita puhelin k√§teen ja k√§vele."
      : "Kosketus on auki, mutta nyt ideana on k√§vell√§. üôÇ";
    $("walkOverlayLeft").textContent = walkLeftSec;
    $("walkOverlay").classList.add("show");
    if(touchLocked){
      // block pointer events on body while overlay open (except modal)
      document.body.style.pointerEvents = "none";
      $("walkOverlay").style.pointerEvents = "auto";
    }
  }

  function hideWalkOverlay(){
    $("walkOverlay").classList.remove("show");
    document.body.style.pointerEvents = "";
    walkLeftSec = 0;
    updateWalkUI();
  }

  $("startWalk").onclick = () => {
    const goal = stateLS.goalMin || 5;
    const remaining = Math.max(0, goal - (stateLS.doneMin || 0));
    if(remaining === 0){
      // already done
      showWalkOverlay(20);
    } else {
      showWalkOverlay(remaining * 60);
    }
    if(walkTimer) clearInterval(walkTimer);
    walkTimer = setInterval(() => {
      if(walkLeftSec <= 0){
        clearInterval(walkTimer);
        walkTimer = null;
        // mark completed minutes
        const goal = stateLS.goalMin || 5;
        stateLS.doneMin = goal;
        saveLS();
        hideWalkOverlay();
        // unlock feel-good
        toast("‚úÖ P√§iv√§ tehty! Pelit auki.");
        return;
      }
      walkLeftSec--;
      $("walkOverlayLeft").textContent = walkLeftSec;
      $("walkLeft").textContent = walkLeftSec + " s";
      if(walkLeftSec % 60 === 0){
        const goal = stateLS.goalMin || 5;
        const doneNow = goal - Math.ceil(walkLeftSec/60);
        $("doneMin").textContent = Math.max(0, doneNow);
      }
    }, 1000);
  };

  $("walkStop").onclick = () => {
    if(walkTimer) clearInterval(walkTimer);
    walkTimer = null;
    hideWalkOverlay();
  };

  function gamesUnlocked(){
    return (stateLS.doneMin || 0) >= (stateLS.goalMin || 5);
  }

  // ---------- Gate / Break logic ----------
  let tokens = stateLS.tokens || 0;
  let gateActive = false;
  let gateLeft = 60;
  let gateTimer = null;

  function updateTokenUI(){
    $("tokens").textContent = tokens;
    stateLS.tokens = tokens;
    saveLS();
  }
  updateTokenUI();

  function openGate(reason){
    gateActive = true;
    gateLeft = 60;
    $("gateTitle").textContent = "‚è∏Ô∏è Taukoportti";
    $("gateText").textContent = reason + " K√§vele / hengit√§. Portin j√§lkeen saat +1 token.";
    $("gateLeft").textContent = gateLeft;
    $("gateOk").disabled = true;
    $("gateOverlay").classList.add("show");

    if(gateTimer) clearInterval(gateTimer);
    gateTimer = setInterval(() => {
      gateLeft--;
      $("gateLeft").textContent = gateLeft;
      if(gateLeft <= 0){
        clearInterval(gateTimer);
        gateTimer = null;
        $("gateOk").disabled = false;
        // reward
        tokens += 1;
        updateTokenUI();
        toast("ü™ô +1 token");
      }
    }, 1000);
  }

  function closeGate(){
    gateActive = false;
    $("gateOverlay").classList.remove("show");
  }

  $("gateOk").onclick = () => closeGate();

  $("gateSkip").onclick = () => {
    if(tokens <= 0){ toast("Ei tokeneita."); return; }
    tokens -= 1;
    updateTokenUI();
    if(gateTimer) { clearInterval(gateTimer); gateTimer=null; }
    $("gateOk").disabled = false;
    closeGate();
    toast("Ohitettu tokenilla.");
  };

  $("gateWatch").onclick = () => {
    // Browser test: 10s "rewarded"
    toast("‚ÄúMainos‚Äù k√§ynniss√§ (10s)...");
    $("gateWatch").disabled = true;
    let t = 10;
    const it = setInterval(() => {
      t--;
      if(t<=0){
        clearInterval(it);
        $("gateWatch").disabled = false;
        if(gateTimer) { clearInterval(gateTimer); gateTimer=null; }
        $("gateOk").disabled = false;
        // give reward + token, close
        tokens += 1;
        updateTokenUI();
        closeGate();
        toast("ü™ô +1 token (testi)");
      }
    }, 1000);
  };

  // ---------- Toast ----------
  let toastT = null;
  function toast(msg){
    let el = $("toast");
    if(!el){
      el = document.createElement("div");
      el.id = "toast";
      el.style.position="fixed";
      el.style.left="50%";
      el.style.bottom="18px";
      el.style.transform="translateX(-50%)";
      el.style.background="rgba(0,0,0,.78)";
      el.style.color="#fff";
      el.style.padding="10px 12px";
      el.style.borderRadius="12px";
      el.style.fontWeight="800";
      el.style.zIndex="10000";
      el.style.maxWidth="92vw";
      el.style.textAlign="center";
      document.body.appendChild(el);
    }
    el.textContent = msg;
    el.style.display="block";
    if(toastT) clearTimeout(toastT);
    toastT = setTimeout(()=>{ el.style.display="none"; }, 1800);
  }

  // ---------- Shared game engine structures ----------
  let mode = "spider"; // spider | scorpion | golf
  let game = null;

  const undoStack = [];
  const redoStack = [];

  let moveCount = 0;
  let invalidCount = 0;
  let seed = (Date.now() >>> 0);
  let savedDeal = null; // for restart same deal

  function resetHistory(){
    undoStack.length = 0;
    redoStack.length = 0;
  }

  function pushUndo(){
    undoStack.push(cloneState(game));
    if(undoStack.length > 60) undoStack.shift();
    redoStack.length = 0;
  }

  function canPlay(){
    if(!gamesUnlocked()){
      openGate("Pelit ovat lukossa ennen p√§iv√§n k√§vely√§.");
      // quick exit: gate is used also here as UX
      return false;
    }
    if(gateActive) return false;
    return true;
  }

  // ---------- Cards ----------
  function makeDeck(numDecks=1){
    const deck = [];
    for(let d=0; d<numDecks; d++){
      for(const s of SUITS){
        for(const r of RANKS){
          deck.push({ r, s });
        }
      }
    }
    return deck;
  }

  function cardLabel(c){
    return c.r + c.s;
  }

  function isRedSuit(s){ return s==="‚ô•" || s==="‚ô¶"; }

  // ---------- Rendering ----------
  let selected = null; // {col, idx, run: [cards], type}
  function clearSelection(){
    selected = null;
    render();
    teacherUpdate();
  }

  function setRulesText(){
    if(mode==="spider"){
      $("rulesText").innerHTML =
        `<b>Spider (kevyt, 1 maa):</b> rakenna laskevia sarjoja (K‚ÜíA). Voit siirt√§√§ vain laskevan ‚Äúrunin‚Äù.
         T√§ysi K‚ÜíA samaa maata poistuu automaattisesti. <br><span class="muted">Valitse kortti ‚Üí valitse kohdepino.</span>`;
      $("foundationRow").style.display="none";
      $("deal").textContent = "Deal 10 korttia";
    } else if(mode==="scorpion"){
      $("rulesText").innerHTML =
        `<b>Scorpion:</b> voit siirt√§√§ mink√§ tahansa <i>face-up</i> kortin ja kaikki sen alla olevat kortit
         toisen pinon p√§√§lle, jos kohdepino alkaa kortilla, joka on <b>1 suurempi</b> ja <b>samaa maata</b>.
         Tyhj√§√§n saa siirt√§√§ vain <b>K</b>. Deal jakaa 3 korttia (1. kolmeen pinoon).`;
      $("foundationRow").style.display="none";
      $("deal").textContent = "Deal 3 (stock)";
    } else if(mode==="golf"){
      $("rulesText").innerHTML =
        `<b>Golf:</b> Siirr√§ pinojen p√§√§llimm√§isi√§ kortteja foundationiin, jos arvo on ¬±1 (A‚ÜîK sallittu).
         Nosta stockista foundationiin kun et voi siirt√§√§. Tarkoitus: tyhjenn√§ tableau.`;
      $("foundationRow").style.display="flex";
      $("deal").textContent = "Nosta stock";
    }
  }

  function render(){
    // HUD
    $("moves").textContent = moveCount;
    $("stockCount").textContent = (game && game.stock) ? game.stock.length : 0;
    $("tokens").textContent = tokens;

    // progress
    if(mode==="spider"){
      $("progress").textContent = (game?.completed || 0) + " / 8";
    } else if(mode==="scorpion"){
      $("progress").textContent = (game?.completed || 0) + " / 4";
    } else {
      $("progress").textContent = (game?.cleared || 0) + " / " + (game?.totalTableau || 0);
      $("foundationCard").textContent = game?.foundation ? cardLabel(game.foundation) : "‚Äî";
      $("golfStock").textContent = game?.stock ? game.stock.length : 0;
    }

    // buttons enabled
    $("undo").disabled = undoStack.length===0 || gateActive;
    $("redo").disabled = redoStack.length===0 || gateActive;

    // Render tableau columns
    const t = $("tableau");
    t.innerHTML = "";

    game.tableau.forEach((col, cIdx) => {
      const colEl = document.createElement("div");
      colEl.className = "col";

      const head = document.createElement("div");
      head.className = "colHeader";
      head.innerHTML = `<span>Pino ${cIdx+1}</span><span>${col.length}</span>`;
      colEl.appendChild(head);

      const stack = document.createElement("div");
      stack.className = "stack";

      col.forEach((cardObj, i) => {
        const cd = document.createElement("div");
        cd.className = "cardDiv";
        if(cardObj.faceDown) cd.classList.add("faceDown");

        // label
        cd.textContent = cardObj.faceDown ? "üÇ†" : cardLabel(cardObj);

        // color
        if(!cardObj.faceDown && isRedSuit(cardObj.s)) cd.style.color = "#b32626";

        // selection
        const isSel =
          selected &&
          selected.col === cIdx &&
          i >= selected.from &&
          i < selected.to;
        if(isSel) cd.classList.add("sel");

        // click behavior
        cd.onclick = (e) => {
          e.preventDefault();
          onCardTap(cIdx, i);
        };

        stack.appendChild(cd);
      });

      // empty column tap target
      colEl.onclick = (e) => {
        if(e.target !== colEl && e.target !== head && e.target !== stack) return;
        onEmptyColumnTap(cIdx);
      };

      colEl.appendChild(stack);
      t.appendChild(colEl);
    });

    // Deal button
    if(mode==="spider"){
      $("deal").disabled = gateActive || !gamesUnlocked() || (game.stock.length < 10) || game.tableau.some(c => c.length===0);
    } else if(mode==="scorpion"){
      $("deal").disabled = gateActive || !gamesUnlocked() || (game.stock.length < 3);
    } else {
      $("deal").disabled = gateActive || !gamesUnlocked() || (game.stock.length===0);
    }
  }

  // ---------- Teacher ----------
  function teacherUpdate(){
    if(!game) return;
    if(!gamesUnlocked()){
      $("teacherText").textContent = "Tee p√§iv√§n k√§vely (3/5/7 min), niin opettaja aktivoituu.";
      return;
    }
    if(!selected){
      $("teacherText").textContent = "Valitse kortti ‚Üí opettaja ehdottaa siirtoa tai varoittaa virheest√§.";
      return;
    }

    // compute best move for selected (simple heuristic)
    const moves = legalTargetsForSelected(selected);
    if(moves.length===0){
      $("teacherText").textContent = "√Ñl√§ tee noin: t√§lle valinnalle ei l√∂ydy yht√§√§n laillista kohdepinoa. Kokeile valita eri kortti (alempi tai eri pino).";
      return;
    }

    // prefer moves that extend longest descending / match suit
    moves.sort((a,b) => b.score - a.score);
    const best = moves[0];
    $("teacherText").innerHTML =
      `‚úÖ Suosittelen: siirr√§ <b>${best.label}</b> ‚Üí <b>Pino ${best.toCol+1}</b>.<br>` +
      `<span class="muted">Peruste: ${best.why}</span>`;
  }

  function legalTargetsForSelected(sel){
    const out = [];
    const runTop = game.tableau[sel.col][sel.from];
    const runBottom = game.tableau[sel.col][sel.to-1];

    for(let c=0;c<game.tableau.length;c++){
      if(c===sel.col) continue;
      const dest = game.tableau[c];
      if(mode==="golf") continue;

      if(dest.length===0){
        if(mode==="scorpion"){
          if(runTop.r==="K"){
            out.push({toCol:c, score: 30, label: cardLabel(runTop), why: "tyhj√§ pino sallii vain K"});
          }
        } else if(mode==="spider"){
          out.push({toCol:c, score: 10, label: cardLabel(runTop), why: "tyhj√§√§n pinoon voi siirt√§√§ runin"});
        }
        continue;
      }

      const destTop = dest[dest.length-1];
      if(destTop.faceDown) continue;

      if(mode==="spider"){
        // can place runTop if destTop is exactly +1 (descending)
        if(rankVal(destTop.r) === rankVal(runTop.r)+1){
          const suitBonus = (destTop.s === runTop.s) ? 12 : 0;
          const lenBonus = (sel.to - sel.from);
          out.push({toCol:c, score: 20 + suitBonus + lenBonus, label: cardLabel(runTop), why: "laskeva jatko (ja maa-bonus jos sama)"});
        }
      } else if(mode==="scorpion"){
        // must be same suit and destTop is +1
        if(destTop.s === runTop.s && rankVal(destTop.r) === rankVal(runTop.r)+1){
          const lenBonus = (sel.to - sel.from);
          out.push({toCol:c, score: 25 + lenBonus, label: cardLabel(runTop), why: "samaa maata ja rank +1"});
        }
      }
    }
    return out;
  }

  // ---------- Selection / Moves ----------
  function buildSpiderRun(colIdx, startIdx){
    const col = game.tableau[colIdx];
    const run = [col[startIdx]];
    // run must be faceUp and descending; for spider we also require same suit to move multi? We'll allow moving descending regardless suit, but teacher rewards same suit.
    for(let i=startIdx; i<col.length-1; i++){
      const a = col[i];
      const b = col[i+1];
      if(a.faceDown || b.faceDown) break;
      if(rankVal(a.r) !== rankVal(b.r)+1) break;
      run.push(b);
    }
    return run;
  }

  function buildScorpionRun(colIdx, startIdx){
    // Scorpion: you can move any face-up card with all cards beneath it (no requirement they be descending)
    const col = game.tableau[colIdx];
    if(col[startIdx].faceDown) return null;
    return col.slice(startIdx);
  }

  function onCardTap(colIdx, idx){
    if(!canPlay()) return;

    const col = game.tableau[colIdx];
    const card = col[idx];
    if(card.faceDown){
      toast("Face-down: et voi siirt√§√§.");
      invalidTry();
      return;
    }

    // First tap: select run
    if(!selected){
      if(mode==="spider"){
        const run = buildSpiderRun(colIdx, idx);
        selected = { col: colIdx, from: idx, to: idx+run.length };
      } else if(mode==="scorpion"){
        const run = buildScorpionRun(colIdx, idx);
        selected = { col: colIdx, from: idx, to: idx + run.length };
      } else if(mode==="golf"){
        // only top card can be selected
        if(idx !== col.length-1){
          toast("Golf: vain p√§√§llimm√§inen.");
          invalidTry();
          return;
        }
        selected = { col: colIdx, from: idx, to: idx+1 };
      }
      render();
      teacherUpdate();
      return;
    }

    // Second tap: if tap within same column, re-select from there
    if(selected && selected.col === colIdx){
      if(mode==="golf"){
        selected = { col: colIdx, from: idx, to: idx+1 };
      } else {
        // reselect
        if(mode==="spider"){
          const run = buildSpiderRun(colIdx, idx);
          selected = { col: colIdx, from: idx, to: idx+run.length };
        } else {
          const run = buildScorpionRun(colIdx, idx);
          selected = { col: colIdx, from: idx, to: idx + run.length };
        }
      }
      render();
      teacherUpdate();
      return;
    }

    // Otherwise: treat tap as choosing destination column = the column tapped
    tryMoveTo(colIdx);
  }

  function onEmptyColumnTap(colIdx){
    if(!canPlay()) return;
    if(!selected) return;
    // move to empty if allowed
    if(game.tableau[colIdx].length !== 0) return;
    tryMoveTo(colIdx);
  }

  function invalidTry(){
    invalidCount++;
    if(invalidCount >= 3){
      invalidCount = 0;
      openGate("3 virheyrityst√§.");
    }
    render();
  }

  function afterAnyMove(){
    moveCount++;
    invalidCount = 0;
    if(moveCount % 25 === 0){
      openGate("25 siirtoa t√§ynn√§.");
    }
    render();
  }

  function flipIfNeeded(colIdx){
    // after move, if top is facedown => flip it (Spider/Scorpion common)
    const col = game.tableau[colIdx];
    if(col.length>0){
      const top = col[col.length-1];
      if(top.faceDown){
        top.faceDown = false;
      }
    }
  }

  function tryMoveTo(destCol){
    if(!selected) return;

    pushUndo();

    const src = game.tableau[selected.col];
    const moving = src.slice(selected.from, selected.to);

    if(mode==="golf"){
      // move top card to foundation if ¬±1
      const card = moving[0];
      const f = game.foundation;
      if(!f){
        // shouldn't happen: foundation exists
        game.foundation = card;
        src.pop();
        afterAnyMove();
        clearSelection();
        checkWin();
        return;
      }
      const a = rankVal(f.r);
      const b = rankVal(card.r);
      const ok = (Math.abs(a-b)===1) || (a===1 && b===13) || (a===13 && b===1);
      if(!ok){
        undoStack.pop(); // cancel
        toast("Ei k√§y foundationiin.");
        invalidTry();
        return;
      }
      // move
      game.foundation = card;
      src.pop();
      afterAnyMove();
      clearSelection();
      checkWin();
      return;
    }

    // Spider / Scorpion dest rules
    const dest = game.tableau[destCol];

    // Destination top
    if(dest.length===0){
      if(mode==="scorpion"){
        if(moving[0].r !== "K"){
          undoStack.pop();
          toast("Scorpion: tyhj√§√§n vain K.");
          invalidTry();
          return;
        }
      }
      // allow
    } else {
      const dt = dest[dest.length-1];
      if(dt.faceDown){
        undoStack.pop();
        toast("Kohdepino on face-down p√§√§lt√§ (ei siirtoa).");
        invalidTry();
        return;
      }
      // must match rules
      const want = rankVal(dt.r) === rankVal(moving[0].r) + 1;
      if(!want){
        undoStack.pop();
        toast("Ei k√§y: kohdekortti ei ole +1.");
        invalidTry();
        return;
      }
      if(mode==="scorpion"){
        if(dt.s !== moving[0].s){
          undoStack.pop();
          toast("Scorpion: t√§ytyy olla sama maa.");
          invalidTry();
          return;
        }
      }
    }

    // Apply move
    game.tableau[destCol].push(...moving);
    game.tableau[selected.col] = src.slice(0, selected.from);
    flipIfNeeded(selected.col);

    // Spider: auto-remove completed K->A same suit run from bottom
    if(mode==="spider"){
      maybeCollectSpider(destCol);
    }
    if(mode==="scorpion"){
      maybeCollectScorpion(destCol);
    }

    afterAnyMove();
    clearSelection();
    checkWin();
  }

  function maybeCollectSpider(colIdx){
    const col = game.tableau[colIdx];
    if(col.length < 13) return;
    // check last 13 are K..A and same suit and faceUp
    const tail = col.slice(col.length-13);
    if(tail.some(c => c.faceDown)) return;
    const suit = tail[0].s;
    for(let i=0;i<13;i++){
      const want = valRank(13-i); // K..A
      if(tail[i].r !== want) return;
      if(tail[i].s !== suit) return;
    }
    // remove
    col.splice(col.length-13, 13);
    game.completed = (game.completed||0) + 1;
    flipIfNeeded(colIdx);
    toast("‚úÖ K‚ÜíA valmis! (+1 valmis)");
  }

  function maybeCollectScorpion(colIdx){
    const col = game.tableau[colIdx];
    if(col.length < 13) return;
    const tail = col.slice(col.length-13);
    if(tail.some(c => c.faceDown)) return;
    const suit = tail[0].s;
    for(let i=0;i<13;i++){
      const want = valRank(13-i);
      if(tail[i].r !== want) return;
      if(tail[i].s !== suit) return;
    }
    col.splice(col.length-13, 13);
    game.completed = (game.completed||0) + 1;
    flipIfNeeded(colIdx);
    toast("ü¶Ç Sarja valmis! (+1)");
  }

  // ---------- Deal actions ----------
  function dealAction(){
    if(!canPlay()) return;

    pushUndo();

    if(mode==="spider"){
      // deal 10 cards, one per column, but only if none empty
      if(game.tableau.some(c => c.length===0)){
        undoStack.pop();
        toast("Spider: et voi dealata jos jokin pino on tyhj√§.");
        invalidTry();
        return;
      }
      if(game.stock.length < 10){
        undoStack.pop();
        toast("Stock tyhj√§.");
        invalidTry();
        return;
      }
      for(let i=0;i<10;i++){
        const c = game.stock.pop();
        c.faceDown = false;
        game.tableau[i].push(c);
      }
      afterAnyMove();
      clearSelection();
      checkWin();
      return;
    }

    if(mode==="scorpion"){
      if(game.stock.length < 3){
        undoStack.pop();
        toast("Stock tyhj√§.");
        invalidTry();
        return;
      }
      // deal 3 to first 3 columns
      for(let i=0;i<3;i++){
        const c = game.stock.pop();
        c.faceDown = false;
        game.tableau[i].push(c);
      }
      afterAnyMove();
      clearSelection();
      checkWin();
      return;
    }

    if(mode==="golf"){
      if(game.stock.length===0){
        undoStack.pop();
        toast("Stock tyhj√§.");
        invalidTry();
        return;
      }
      // draw to foundation
      game.foundation = game.stock.pop();
      game.foundation.faceDown = false;
      afterAnyMove();
      clearSelection();
      checkWin();
      return;
    }
  }

  // ---------- New game setups ----------
  function newSpider(seedIn){
    const oneSuitDeck = [];
    // Spider MVP: build 8 decks but all ‚ô† for simplicity and fairness
    for(let d=0; d<8; d++){
      for(const r of RANKS){
        oneSuitDeck.push({ r, s:"‚ô†" });
      }
    }
    const deck = shuffle(oneSuitDeck, seedIn);

    const tableau = Array.from({length:10}, () => []);
    // Spider: 54 in tableau: first 4 columns 6 cards, next 6 columns 5 cards; last card faceUp, others faceDown
    for(let c=0;c<10;c++){
      const count = (c<4) ? 6 : 5;
      for(let i=0;i<count;i++){
        const card = deck.pop();
        card.faceDown = (i < count-1);
        tableau[c].push(card);
      }
    }
    // remaining = stock (50 cards)
    deck.forEach(c => c.faceDown=false);

    return {
      tableau,
      stock: deck,
      completed: 0,
      seed: seedIn,
      type: "spider"
    };
  }

  function newScorpion(seedIn){
    const deck = shuffle(makeDeck(1), seedIn);

    // Scorpion standard: 7 columns x 7 cards = 49.
    // First 4 columns: first 3 faceDown, rest faceUp. Remaining 3 columns all faceUp.
    // Stock: last 3 cards.
    const tableau = Array.from({length:7}, () => []);
    for(let col=0; col<7; col++){
      for(let i=0; i<7; i++){
        const card = deck.pop();
        const faceDown = (col < 4) ? (i < 3) : false;
        card.faceDown = faceDown;
        tableau[col].push(card);
      }
    }
    // stock: 3
    const stock = deck.slice(-3);
    stock.forEach(c => c.faceDown=false);

    return {
      tableau,
      stock,
      completed: 0,
      seed: seedIn,
      type: "scorpion"
    };
  }

  function newGolf(seedIn){
    const deck = shuffle(makeDeck(1), seedIn);
    // Golf: 7 columns x 5 = 35 faceUp, stock = 16, foundation = 1
    const tableau = Array.from({length:7}, () => []);
    for(let r=0; r<5; r++){
      for(let c=0;c<7;c++){
        const card = deck.pop();
        card.faceDown = false;
        tableau[c].push(card);
      }
    }
    const foundation = deck.pop();
    foundation.faceDown = false;
    deck.forEach(c => c.faceDown=false);

    return {
      tableau,
      stock: deck,
      foundation,
      cleared: 0,
      totalTableau: 35,
      seed: seedIn,
      type: "golf"
    };
  }

  function loadMode(m){
    mode = m;
    setRulesText();
    resetHistory();
    moveCount = 0;
    invalidCount = 0;
    selected = null;

    // restore saved deal per mode if exists
    const saved = stateLS.savedDeals || {};
    if(saved[m]){
      try{
        game = JSON.parse(saved[m]);
      } catch {
        game = null;
      }
    }
    if(!game || game.type !== m){
      seed = (Date.now() >>> 0);
      if(m==="spider") game = newSpider(seed);
      if(m==="scorpion") game = newScorpion(seed);
      if(m==="golf") game = newGolf(seed);
      saveCurrentDeal();
    }
    savedDeal = cloneState(game);
    render();
    teacherUpdate();
  }

  function saveCurrentDeal(){
    stateLS.savedDeals = stateLS.savedDeals || {};
    stateLS.savedDeals[mode] = JSON.stringify(game);
    saveLS();
  }

  function hardNewDeal(){
    seed = (Date.now() >>> 0);
    if(mode==="spider") game = newSpider(seed);
    if(mode==="scorpion") game = newScorpion(seed);
    if(mode==="golf") game = newGolf(seed);
    savedDeal = cloneState(game);
    saveCurrentDeal();
    resetHistory();
    moveCount = 0;
    invalidCount = 0;
    selected = null;
    render();
    teacherUpdate();
  }

  function restartSameDeal(){
    if(!savedDeal) return;
    game = cloneState(savedDeal);
    resetHistory();
    moveCount = 0;
    invalidCount = 0;
    selected = null;
    render();
    teacherUpdate();
  }

  // ---------- Undo/redo ----------
  $("undo").onclick = () => {
    if(!canPlay()) return;
    if(undoStack.length===0) return;
    redoStack.push(cloneState(game));
    game = undoStack.pop();
    selected = null;
    render();
    teacherUpdate();
    saveCurrentDeal();
  };

  $("redo").onclick = () => {
    if(!canPlay()) return;
    if(redoStack.length===0) return;
    undoStack.push(cloneState(game));
    game = redoStack.pop();
    selected = null;
    render();
    teacherUpdate();
    saveCurrentDeal();
  };

  // ---------- Win checks ----------
  function checkWin(){
    if(mode==="spider"){
      if((game.completed||0) >= 8){
        toast("üèÅ Spider l√§pi!");
      }
    } else if(mode==="scorpion"){
      if((game.completed||0) >= 4){
        toast("üèÅ Scorpion l√§pi!");
      }
    } else {
      const remaining = game.tableau.reduce((s,c)=>s+c.length,0);
      game.cleared = game.totalTableau - remaining;
      if(remaining === 0){
        toast("üèÅ Golf l√§pi!");
      }
    }
    saveCurrentDeal();
  }

  // ---------- UI wiring ----------
  $("tabSpider").onclick = () => {
    $("tabSpider").classList.add("active");
    $("tabScorpion").classList.remove("active");
    $("tabGolf").classList.remove("active");
    loadMode("spider");
  };
  $("tabScorpion").onclick = () => {
    $("tabScorpion").classList.add("active");
    $("tabSpider").classList.remove("active");
    $("tabGolf").classList.remove("active");
    loadMode("scorpion");
  };
  $("tabGolf").onclick = () => {
    $("tabGolf").classList.add("active");
    $("tabSpider").classList.remove("active");
    $("tabScorpion").classList.remove("active");
    loadMode("golf");
  };

  $("newGame").onclick = () => { if(canPlay()) hardNewDeal(); };
  $("restartDeal").onclick = () => { if(canPlay()) restartSameDeal(); };
  $("deal").onclick = () => { dealAction(); };

  // click outside to clear selection
  $("tableau").addEventListener("click", (e) => {
    // if click on tableau background (not card), clear selection
    if(e.target === $("tableau")) clearSelection();
  });

  // Copy whole HTML
  $("copyBtn").onclick = async () => {
    try{
      const html = "<!doctype html>" + document.documentElement.outerHTML;
      await navigator.clipboard.writeText(html);
      toast("Kopioitu!");
    }catch{
      toast("Kopiointi estetty selaimessa.");
    }
  };

  // Start default mode
  setRulesText();
  loadMode("spider");

  // Ensure gate blocks play if not unlocked
  if(!gamesUnlocked()){
    toast("Tee p√§iv√§n k√§vely niin pelit aukeavat.");
  }

})();
</script>
</body>
</html>
```Ó®Å0Ó®Ç
