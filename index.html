<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Walking Spider Sol ‚Äî Taukoportti (60s)</title>

  <!-- AdSense (sama client kuin aiemmin) -->
  <script async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7652525244986434"
    crossorigin="anonymous"></script>

  <style>
    :root{
      --bg1:#063b34; --bg2:#0b5f52;
      --card:#ffffff; --txt:#10211e; --muted:#5b6f6b;
      --shadow:0 12px 28px rgba(0,0,0,.22);
      --r:18px;

      /* table sizing */
      --pileW: 86px;      /* will scale */
      --cardH: 66px;
      --offset: 24px;

      --btn:#0b5f52;
      --btn2:#1f8b63;
      --sel:#ffe08a;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:linear-gradient(180deg,var(--bg1),var(--bg2));
      color:#fff;
      -webkit-tap-highlight-color: transparent;
      overflow-x:hidden;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:12px 12px 20px}
    .topbar{
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
      margin-bottom:10px;
    }
    .brand{font-weight:1100;letter-spacing:-.2px}
    .chips{display:flex;gap:8px;flex-wrap:wrap}
    .chip{
      display:inline-flex;align-items:center;gap:8px;
      padding:9px 12px;border-radius:999px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.18);
      font-weight:1000;user-select:none;
    }
    .chip b{font-variant-numeric:tabular-nums}
    .mono{font-variant-numeric:tabular-nums}

    .btnrow{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
    .btn{
      border:0;border-radius:14px;
      padding:12px 14px;
      background:var(--btn);
      color:#fff;font-weight:1100;
      cursor:pointer;
      user-select:none;
    }
    .btn.secondary{background:#2a6f62}
    .btn.green{background:var(--btn2)}
    .btn.ghost{background:transparent;border:2px solid rgba(255,255,255,.22); color:#fff}
    .btn:disabled{opacity:.55;cursor:not-allowed}
    .btn:active{transform:scale(.99)}
    .small{font-size:13px;opacity:.82;line-height:1.45}

    .layout{display:grid;grid-template-columns:1fr;gap:12px}
    .card{
      background:#fff; color:var(--txt);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      padding:14px;
    }
    .hint{
      margin-top:8px;
      padding:10px 12px;border-radius:14px;
      border:1px solid #dbe5e3;
      background:#fbfffe;
      color:#1a2c29;
    }

    .boardOuter{
      border-radius:22px;
      padding:12px;
      background:linear-gradient(180deg,rgba(255,255,255,.08),rgba(255,255,255,.05));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.10);
      overflow:hidden;
    }
    .boardScaleWrap{
      transform-origin: top left;
      will-change: transform;
    }
    .piles{
      display:flex;
      gap:10px;
      align-items:flex-start;
      width:max-content;
      min-width:max-content;
    }

    .pile{
      position:relative;
      width:var(--pileW);
      min-height:520px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      padding:8px 6px 10px;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      flex:0 0 auto;
    }
    .pile.empty::after{
      content:"";
      position:absolute;inset:10px 8px auto 8px;
      height:60px;border-radius:12px;
      border:2px dashed rgba(255,255,255,.26);
      opacity:.8;
    }
    .cards{position:relative;height:100%;min-height:520px}

    .cardEl{
      position:absolute;left:0;right:0;
      height:var(--cardH);
      border-radius:14px;
      border:1px solid rgba(0,0,0,.08);
      box-shadow:0 10px 18px rgba(0,0,0,.16);
      background:#fff;
      display:flex;align-items:flex-start;justify-content:space-between;
      padding:8px 10px;
      color:#10211e;
      font-weight:1100;
      transform: translateZ(0);
    }
    .cardEl .rank{font-size:18px;line-height:1}
    .cardEl .suit{font-size:18px;line-height:1}
    .cardEl .mini{font-size:12px;opacity:.75;font-weight:900;line-height:1.1}
    .cardEl.selected{
      outline:3px solid var(--sel);
      box-shadow:0 16px 26px rgba(255,224,138,.28);
      z-index:999;
    }
    .cardEl.selTail{outline:3px solid rgba(255,224,138,.55)}

    .pile.targetOK{box-shadow: inset 0 0 0 3px rgba(56,161,105,.55)}
    .pile.targetNO{box-shadow: inset 0 0 0 3px rgba(214,69,69,.55)}
    @keyframes flashRed {
      0% { box-shadow: inset 0 0 0 0 rgba(214,69,69,0); }
      40% { box-shadow: inset 0 0 0 4px rgba(214,69,69,.85); }
      100% { box-shadow: inset 0 0 0 0 rgba(214,69,69,0); }
    }
    .pile.flashBad{ animation: flashRed .35s ease; }

    .stockRow{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
      margin-top:10px;
    }
    .stockStack{
      display:inline-flex;align-items:center;gap:8px;
      padding:10px 12px;border-radius:14px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.18);
      color:#fff;font-weight:1100;
    }
    .adbox{
      background:rgba(255,255,255,.08);
      border:2px dashed rgba(255,255,255,.22);
      color:rgba(255,255,255,.88);
      border-radius:16px;
      padding:12px;
      text-align:center;
      font-weight:1100;
    }

    .toast{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      background:rgba(0,0,0,.78);color:#fff;
      padding:10px 12px;border-radius:999px;
      font-weight:1100;font-size:13px;
      display:none;z-index:10000;
      border:1px solid rgba(255,255,255,.14)
    }
    .toast.show{display:block}

    /* ===== Taukoportti overlay ===== */
    .gate{
      position:fixed; inset:0;
      background:rgba(0,0,0,.72);
      display:none;
      z-index:20000;
      align-items:center; justify-content:center;
      padding:14px;
    }
    .gate.show{display:flex}
    .gateCard{
      width:min(720px, 100%);
      background:#fff;
      color:#10211e;
      border-radius:22px;
      box-shadow:0 18px 48px rgba(0,0,0,.45);
      padding:14px;
    }
    .gateTop{
      display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap;
    }
    .gateTitle{font-size:18px;font-weight:1100;margin:0}
    .gateReason{font-size:13px;color:#5b6f6b;margin-top:4px;line-height:1.35}
    .gateTimer{
      font-size:34px;font-weight:1200;letter-spacing:.5px;
      font-variant-numeric:tabular-nums;
      background:rgba(11,95,82,.08);
      border:1px solid rgba(11,95,82,.18);
      padding:10px 12px;border-radius:18px;
      min-width:150px;text-align:center;
    }
    .gateActions{
      display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;
    }
    .gateActions .btn{flex:1;min-width:180px}
    .gateAds{
      margin-top:12px;
      border-radius:18px;
      background:rgba(11,95,82,.06);
      border:1px dashed rgba(11,95,82,.22);
      padding:12px;
    }
    .gateAds .small{color:#2a3b38;opacity:.85}
    .gateFooter{
      margin-top:10px;
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
      color:#5b6f6b;font-size:13px;
    }
    .badge{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      background:rgba(11,95,82,.08);
      border:1px solid rgba(11,95,82,.18);
      font-weight:1000;
    }

    /* responsive: scale columns to fit */
    @media (max-width: 520px){
      :root{ --pileW: 76px; --cardH: 62px; --offset: 22px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">üï∑Ô∏è Walking Spider Sol</div>
      <div class="chips">
        <div class="chip">üßÆ Siirrot <b class="mono" id="movesCount">0</b></div>
        <div class="chip">üèÅ Maat <b class="mono" id="setsDone">0</b>/8</div>
        <div class="chip">üì¶ Stock <b class="mono" id="stockLeft">50</b></div>
        <div class="chip">ü™ô Token <b class="mono" id="tokensView">0</b></div>
      </div>
    </div>

    <div class="layout">
      <div class="card">
        <div class="btnrow">
          <button class="btn green" id="btnNew">New game</button>
          <button class="btn secondary" id="btnRestart">Restart sama jako</button>
          <button class="btn secondary" id="btnUndo">Undo</button>
          <button class="btn secondary" id="btnRedo">Redo</button>
          <button class="btn" id="btnDeal">Deal 10 korttia</button>
          <button class="btn ghost" id="btnFit">Sovita ruutuun: <span class="mono" id="fitState">ON</span></button>
        </div>

        <div class="hint">
          <b>Ohje:</b> Napauta korttia ‚Üí valitset laskevan sarjan. Napauta kohdepinoa ‚Üí siirt√§√§ heti.<br>
          <span class="small"><b>Taukoportti:</b> joka 25. siirto ja 3 virheyrityst√§ k√§ynnist√§√§ 60s portin. Portin j√§lkeen saat +1 token. Tokenilla voit ohittaa portin kerran.</span>
        </div>

        <div class="small" style="margin-top:10px;opacity:.75">
          <a href="./privacy.html" style="color:#0b5f52;font-weight:1100;text-decoration:none">Tietosuoja</a>
        </div>
      </div>

      <div class="boardOuter" id="boardOuter">
        <div class="boardScaleWrap" id="boardScaleWrap">
          <div class="piles" id="piles"></div>

          <div class="stockRow">
            <div class="stockStack">Seed: <span class="mono" id="seedView">‚Äî</span></div>
            <div style="max-width:520px;width:100%">
              <div class="adbox">
                Mainosalue (Auto Ads / bannerit)
                <div class="small" style="margin-top:6px;opacity:.7">
                  T√§m√§ on paikka mainoksille my√∂s pelialueella.
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between">
          <div>
            <div style="font-weight:1100">Ty√∂kalut</div>
            <div class="small">Kopioi / tuo tallennus (JSON).</div>
          </div>
          <div style="display:flex;gap:10px;flex-wrap:wrap">
            <button class="btn ghost" id="btnCopy">üìã Kopioi t√§m√§</button>
            <button class="btn ghost" id="btnImport">‚¨áÔ∏è Tuo tallennus</button>
            <button class="btn ghost" id="btnClearSave">üßπ Poista tallennus</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Taukoportti -->
  <div class="gate" id="gate">
    <div class="gateCard">
      <div class="gateTop">
        <div style="flex:1;min-width:240px">
          <h2 class="gateTitle" id="gateTitle">Taukoportti</h2>
          <div class="gateReason" id="gateReason">‚Äî</div>
          <div class="gateFooter">
            <div class="badge">üß± Portti: <span class="mono">60s</span></div>
            <div class="badge">ü™ô Tokenit: <span class="mono" id="gateTokens">0</span></div>
          </div>
        </div>
        <div class="gateTimer" id="gateTimer">60</div>
      </div>

      <div class="gateAds">
        <div style="font-weight:1100">Mainosalue tauon aikana</div>
        <div class="small" style="margin-top:6px">
          N√§yt√§ t√§ss√§ Auto Ads / bannerit. Testiss√§ portti avautuu ajalla (60s).
        </div>
        <div style="margin-top:10px">
          <div class="adbox" style="color:#0f201d;border-color:rgba(11,95,82,.25);background:rgba(11,95,82,.06)">
            (Mainos n√§kyy t√§√§ll√§ jos AdSense n√§ytt√§√§)
          </div>
        </div>
      </div>

      <div class="gateActions">
        <button class="btn green" id="btnContinue" disabled>Jatka (kun timer valmis)</button>
        <button class="btn secondary" id="btnSkip">Ohita tokenilla (1)</button>
      </div>

      <div class="small" style="margin-top:10px;opacity:.8">
        Vinkki: tauon idea on katkaista putki. Tokenit tekee t√§st√§ siedett√§v√§n testiss√§.
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);

  const LS = {
    save: "ws_spider_save_gate_v1",
    seed: "ws_spider_seed_gate_v1",
    fit:  "ws_spider_fit_gate_v1",
  };

  // Gate settings
  const GATE_SECONDS = 60;
  const MOVE_GATE_EVERY = 25;
  const INVALID_GATE_AT = 3;

  const CFG = {
    PILES: 10,
    INITIAL_PILES_6: 4,
    TOTAL_SETS: 8
  };

  function mulberry32(a){
    return function() {
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }
  function randomSeed(){
    return (Math.floor(Math.random()*1e9) ^ Date.now()) >>> 0;
  }

  let fitOn = (localStorage.getItem(LS.fit) ?? "1") === "1";
  $("fitState").textContent = fitOn ? "ON" : "OFF";

  let state = {
    seed: 0,
    rng: null,
    piles: [],
    stock: [],
    setsDone: 0,
    moves: 0,
    selected: null,
    history: [],
    future: [],

    // gate
    tokens: 0,
    invalidStreak: 0,         // counts invalid target attempts
    nextMoveGateAt: MOVE_GATE_EVERY, // first gate at 25
    gateOpen: false,
    gateRemaining: 0,
    gateReason: ""
  };

  function toast(msg){
    const t = $("toast");
    t.textContent = msg;
    t.classList.add("show");
    setTimeout(()=>t.classList.remove("show"), 1200);
  }

  function cardLabel(r){
    const map = {1:"A", 11:"J", 12:"Q", 13:"K"};
    return map[r] || String(r);
  }

  function snapshot(){
    return JSON.stringify({
      seed: state.seed,
      piles: state.piles,
      stock: state.stock,
      setsDone: state.setsDone,
      moves: state.moves,
      tokens: state.tokens,
      invalidStreak: state.invalidStreak,
      nextMoveGateAt: state.nextMoveGateAt
    });
  }

  function restoreFromSnap(json){
    const s = JSON.parse(json);
    state.seed = (s.seed >>> 0);
    state.rng = mulberry32(state.seed);
    state.piles = s.piles;
    state.stock = s.stock;
    state.setsDone = s.setsDone;
    state.moves = s.moves;
    state.selected = null;
    state.history = [json];
    state.future = [];
    state.tokens = s.tokens ?? 0;
    state.invalidStreak = s.invalidStreak ?? 0;
    state.nextMoveGateAt = s.nextMoveGateAt ?? MOVE_GATE_EVERY;

    // ensure gate closed on load
    state.gateOpen = false;
    state.gateRemaining = 0;
    state.gateReason = "";
    hideGate(true);
  }

  function pushHistory(){
    state.history.push(snapshot());
    if(state.history.length > 250) state.history.shift();
    state.future = [];
  }

  function buildDeck(){
    // Spider standard here: 8 sets of ranks (Open: use ‚ô† only visually)
    const deck = [];
    let uid = 1;
    for(let k=0;k<CFG.TOTAL_SETS;k++){
      for(let r=1;r<=13;r++){
        deck.push({r, f:true, uid: uid++});
      }
    }
    return deck;
  }

  function shuffle(deck, rng){
    for(let i=deck.length-1;i>0;i--){
      const j = Math.floor(rng() * (i+1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
  }

  function saveGame(){
    localStorage.setItem(LS.save, snapshot());
    localStorage.setItem(LS.seed, String(state.seed));
  }

  function loadGame(){
    const s = localStorage.getItem(LS.save);
    if(!s) return false;
    restoreFromSnap(s);
    renderAll();
    return true;
  }

  function newGame(seed){
    state.seed = seed >>> 0;
    state.rng = mulberry32(state.seed);
    state.piles = Array.from({length:CFG.PILES}, () => []);
    state.stock = [];
    state.setsDone = 0;
    state.moves = 0;
    state.selected = null;
    state.history = [];
    state.future = [];

    state.tokens = 0;
    state.invalidStreak = 0;
    state.nextMoveGateAt = MOVE_GATE_EVERY;

    state.gateOpen = false;
    state.gateRemaining = 0;
    state.gateReason = "";
    hideGate(true);

    const deck = buildDeck();
    shuffle(deck, state.rng);

    for(let i=0;i<CFG.PILES;i++){
      const cnt = (i < CFG.INITIAL_PILES_6) ? 6 : 5;
      for(let c=0;c<cnt;c++){
        state.piles[i].push(deck.pop());
      }
    }

    state.stock = deck.map(c => ({...c, f:true}));

    pushHistory();
    renderAll();
    saveGame();
    toast("Uusi peli.");
  }

  function restartSame(){
    newGame(state.seed);
  }

  // ===== Gate logic =====
  let gateTimerHandle = null;

  function openGate(reason){
    if(state.gateOpen) return;

    state.gateOpen = true;
    state.gateRemaining = GATE_SECONDS;
    state.gateReason = reason;

    $("gateTitle").textContent = "Taukoportti";
    $("gateReason").textContent = reason;
    $("gateTimer").textContent = String(GATE_SECONDS);
    $("btnContinue").disabled = true;
    $("gateTokens").textContent = String(state.tokens);
    $("btnSkip").disabled = (state.tokens <= 0);

    $("gate").classList.add("show");

    clearInterval(gateTimerHandle);
    gateTimerHandle = setInterval(() => {
      if(!state.gateOpen) return;
      state.gateRemaining -= 1;
      if(state.gateRemaining <= 0){
        state.gateRemaining = 0;
        $("gateTimer").textContent = "0";
        $("btnContinue").disabled = false;
        clearInterval(gateTimerHandle);
      } else {
        $("gateTimer").textContent = String(state.gateRemaining);
      }
    }, 1000);
  }

  function hideGate(silent=false){
    state.gateOpen = false;
    state.gateRemaining = 0;
    state.gateReason = "";
    $("gate").classList.remove("show");
    clearInterval(gateTimerHandle);
    gateTimerHandle = null;
    if(!silent) renderAll();
  }

  function completeGate(){
    // Give token for completing the gate
    state.tokens += 1;
    state.invalidStreak = 0; // reset mistakes
    saveGame();
    hideGate(true);
    renderAll();
    toast("+1 token");
  }

  function skipGateWithToken(){
    if(state.tokens <= 0) return;
    state.tokens -= 1;
    state.invalidStreak = 0; // reset mistakes
    saveGame();
    hideGate(true);
    renderAll();
    toast("Ohitettu tokenilla");
  }

  $("btnContinue").addEventListener("click", () => {
    if(!state.gateOpen) return;
    if(state.gateRemaining > 0) return;
    completeGate();
  });

  $("btnSkip").addEventListener("click", () => {
    if(!state.gateOpen) return;
    skipGateWithToken();
  });

  function gateCheckAfterMove(){
    // 1) every 25 moves
    if(state.moves >= state.nextMoveGateAt){
      state.nextMoveGateAt += MOVE_GATE_EVERY;
      openGate(`‚è±Ô∏è ${MOVE_GATE_EVERY} siirtoa tehty. Pidet√§√§n 60s tauko.`);
      return true;
    }
    return false;
  }

  function gateCheckAfterInvalid(){
    if(state.invalidStreak >= INVALID_GATE_AT){
      state.invalidStreak = 0;
      openGate(`üß† 3 virheyrityst√§ per√§kk√§in. Taukoportti auttaa katkaisemaan putken.`);
      return true;
    }
    return false;
  }

  function mustBlockInput(){
    return state.gateOpen;
  }

  // ===== Game rules =====
  function canDeal(){
    if(state.stock.length < CFG.PILES) return false;
    for(const p of state.piles) if(p.length === 0) return false;
    return true;
  }

  function deal10(){
    if(mustBlockInput()) return;
    if(!canDeal()){
      toast("Deal ei onnistu.");
      return;
    }
    pushHistory();
    for(let i=0;i<CFG.PILES;i++){
      const card = state.stock.pop();
      card.f = true;
      state.piles[i].push(card);
    }
    state.moves += 1;
    state.invalidStreak = 0;
    checkCompletedSets();
    renderAll();
    saveGame();

    gateCheckAfterMove();
  }

  function isValidDescendingRun(pile, fromIndex){
    for(let i=fromIndex;i<pile.length;i++){
      if(!pile[i].f) return false;
      if(i > fromIndex){
        if(pile[i-1].r !== pile[i].r + 1) return false;
      }
    }
    return true;
  }

  function canPlace(runTopRank, targetPile){
    if(targetPile.length === 0) return true;
    const top = targetPile[targetPile.length-1];
    if(!top.f) return false;
    return top.r === runTopRank + 1;
  }

  function flashBad(pileIndex){
    const el = document.querySelector(`.pile[data-pile="${pileIndex}"]`);
    if(!el) return;
    el.classList.remove("flashBad");
    void el.offsetWidth;
    el.classList.add("flashBad");
  }

  function moveRun(fromPileIdx, fromIndex, toPileIdx){
    if(mustBlockInput()) return false;

    const fromPile = state.piles[fromPileIdx];
    const toPile = state.piles[toPileIdx];
    const run = fromPile.slice(fromIndex);

    if(!isValidDescendingRun(fromPile, fromIndex)){
      flashBad(fromPileIdx);
      return false;
    }
    const runTop = run[0];
    if(!canPlace(runTop.r, toPile)){
      flashBad(toPileIdx);
      state.invalidStreak += 1;
      saveGame();
      renderAll();
      gateCheckAfterInvalid();
      return false;
    }

    pushHistory();

    state.piles[toPileIdx] = toPile.concat(run);
    state.piles[fromPileIdx] = fromPile.slice(0, fromIndex);

    state.moves += 1;
    state.invalidStreak = 0;
    state.selected = null;

    checkCompletedSets();
    renderAll();
    saveGame();

    gateCheckAfterMove();
    return true;
  }

  function isCompleteKA(pile){
    if(pile.length < 13) return false;
    const tail = pile.slice(pile.length-13);
    for(let i=0;i<13;i++){
      const card = tail[i];
      if(!card.f) return false;
      const want = 13 - i;
      if(card.r !== want) return false;
    }
    return true;
  }

  function checkCompletedSets(){
    let removed = 0;
    for(let i=0;i<CFG.PILES;i++){
      const pile = state.piles[i];
      if(isCompleteKA(pile)){
        state.piles[i] = pile.slice(0, pile.length-13);
        removed += 1;
      }
    }
    if(removed > 0){
      state.setsDone += removed;
      toast("Valmis maa! +" + removed);
    }
  }

  function undo(){
    if(mustBlockInput()) return;
    if(state.history.length <= 1) return;
    const cur = state.history.pop();
    state.future.push(cur);
    const prev = state.history[state.history.length-1];
    restoreFromSnap(prev);
    renderAll();
    saveGame();
  }

  function redo(){
    if(mustBlockInput()) return;
    if(state.future.length === 0) return;
    const next = state.future.pop();
    state.history.push(next);
    restoreFromSnap(next);
    renderAll();
    saveGame();
  }

  // ===== Render =====
  function renderAll(){
    $("setsDone").textContent = state.setsDone;
    $("stockLeft").textContent = state.stock.length;
    $("movesCount").textContent = state.moves;
    $("seedView").textContent = state.seed;
    $("tokensView").textContent = state.tokens;

    $("btnDeal").disabled = !canDeal() || mustBlockInput();
    $("btnUndo").disabled = (state.history.length <= 1) || mustBlockInput();
    $("btnRedo").disabled = (state.future.length === 0) || mustBlockInput();

    renderPiles();
    applyFit();
  }

  function clearTargetClasses(){
    document.querySelectorAll(".pile").forEach(p => p.classList.remove("targetOK","targetNO"));
  }

  function paintTargets(){
    clearTargetClasses();
    if(!state.selected) return;

    const fromPile = state.piles[state.selected.pileIndex];
    const run = fromPile.slice(state.selected.fromIndex);
    const runTopRank = run[0].r;

    document.querySelectorAll(".pile").forEach(p => {
      const idx = Number(p.dataset.pile);
      if(idx === state.selected.pileIndex) return;
      const ok = canPlace(runTopRank, state.piles[idx]);
      p.classList.add(ok ? "targetOK" : "targetNO");
    });
  }

  function renderPiles(){
    const pilesEl = $("piles");
    pilesEl.innerHTML = "";

    const offset = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--offset")) || 24;

    for(let i=0;i<CFG.PILES;i++){
      const pile = state.piles[i];

      const pileWrap = document.createElement("div");
      pileWrap.className = "pile" + (pile.length === 0 ? " empty" : "");
      pileWrap.dataset.pile = String(i);

      const cardsWrap = document.createElement("div");
      cardsWrap.className = "cards";

      const sel = state.selected && state.selected.pileIndex === i ? state.selected : null;

      for(let c=0;c<pile.length;c++){
        const card = pile[c];
        const cardEl = document.createElement("div");
        cardEl.className = "cardEl";
        cardEl.style.top = (c * offset) + "px";
        cardEl.dataset.pile = String(i);
        cardEl.dataset.index = String(c);

        const rank = document.createElement("div");
        rank.className = "rank";
        rank.textContent = cardLabel(card.r);

        const suit = document.createElement("div");
        suit.className = "suit";
        suit.textContent = "‚ô†";

        const mini = document.createElement("div");
        mini.className = "mini";
        mini.textContent = "";

        cardEl.appendChild(rank);
        cardEl.appendChild(mini);
        cardEl.appendChild(suit);

        if(sel && c === sel.fromIndex) cardEl.classList.add("selected");
        if(sel && c > sel.fromIndex) cardEl.classList.add("selTail");

        cardEl.addEventListener("click", (e) => {
          e.stopPropagation();
          if(mustBlockInput()) return;

          if(state.selected && state.selected.pileIndex !== i){
            moveRun(state.selected.pileIndex, state.selected.fromIndex, i);
            return;
          }
          onCardSelect(i, c);
        });

        cardsWrap.appendChild(cardEl);
      }

      pileWrap.addEventListener("click", () => {
        if(mustBlockInput()) return;

        if(!state.selected) return;

        if(state.selected.pileIndex === i){
          state.selected = null;
          renderPiles();
          applyFit();
          return;
        }
        moveRun(state.selected.pileIndex, state.selected.fromIndex, i);
      });

      pileWrap.appendChild(cardsWrap);
      pilesEl.appendChild(pileWrap);
    }

    paintTargets();
  }

  function onCardSelect(pileIndex, cardIndex){
    const pile = state.piles[pileIndex];

    if(state.selected &&
       state.selected.pileIndex === pileIndex &&
       state.selected.fromIndex === cardIndex){
      state.selected = null;
      renderPiles();
      applyFit();
      return;
    }

    if(!isValidDescendingRun(pile, cardIndex)){
      flashBad(pileIndex);
      return;
    }

    state.selected = {pileIndex, fromIndex: cardIndex};
    renderPiles();
    applyFit();
  }

  // Fit-to-screen
  function applyFit(){
    const wrap = $("boardScaleWrap");
    if(!wrap) return;

    if(!fitOn){
      wrap.style.transform = "scale(1)";
      return;
    }

    const outer = $("boardOuter");
    const outerStyle = getComputedStyle(outer);
    const padL = parseFloat(outerStyle.paddingLeft) || 0;
    const padR = parseFloat(outerStyle.paddingRight) || 0;
    const available = outer.clientWidth - padL - padR;

    const pilesEl = $("piles");
    const contentWidth = pilesEl.scrollWidth;
    const scale = Math.min(1, available / contentWidth);

    wrap.style.transform = `scale(${scale})`;
  }

  window.addEventListener("resize", () => applyFit());

  // Copy / import helpers
  async function copyText(text){
    try{
      await navigator.clipboard.writeText(text);
      return true;
    }catch(_){
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand("copy"); document.body.removeChild(ta); return true; }
      catch(e){ document.body.removeChild(ta); return false; }
    }
  }

  $("btnCopy").addEventListener("click", async () => {
    const ok = await copyText(localStorage.getItem(LS.save) || snapshot());
    toast(ok ? "Kopioitu!" : "Kopiointi ep√§onnistui.");
  });

  $("btnImport").addEventListener("click", () => {
    const txt = prompt("Liit√§ tallennus (JSON) t√§h√§n:");
    if(!txt) return;
    try{
      restoreFromSnap(txt);
      saveGame();
      renderAll();
      toast("Tallennus tuotu!");
    }catch(e){
      toast("Virhe tallennuksessa.");
    }
  });

  $("btnClearSave").addEventListener("click", () => {
    localStorage.removeItem(LS.save);
    toast("Tallennus poistettu.");
  });

  // Buttons
  $("btnNew").addEventListener("click", () => {
    const seed = randomSeed();
    localStorage.setItem(LS.seed, String(seed));
    newGame(seed);
  });
  $("btnRestart").addEventListener("click", restartSame);
  $("btnUndo").addEventListener("click", undo);
  $("btnRedo").addEventListener("click", redo);
  $("btnDeal").addEventListener("click", deal10);

  $("btnFit").addEventListener("click", () => {
    fitOn = !fitOn;
    localStorage.setItem(LS.fit, fitOn ? "1" : "0");
    $("fitState").textContent = fitOn ? "ON" : "OFF";
    applyFit();
  });

  // Gate should block keyboard too (if any)
  document.addEventListener("keydown", (e)=>{
    if(!mustBlockInput()) return;
    e.preventDefault();
  }, {capture:true});

  // Init
  const loaded = loadGame();
  if(!loaded){
    const s = Number(localStorage.getItem(LS.seed) || 0);
    const seed = s ? (s >>> 0) : randomSeed();
    localStorage.setItem(LS.seed, String(seed));
    newGame(seed);
  } else {
    toast("Tallennus ladattu.");
  }
})();
</script>
</body>
</html>
```Ó®Å0Ó®Ç 
